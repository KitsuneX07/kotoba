/// Macro-driven provider registration system.
///
/// This module provides the `register_providers!` macro that automatically generates:
/// - The `ProviderKind` enum with proper serde attributes
/// - The `build_provider_from_config()` function for constructing providers
/// - The `list_provider_types()` function for enumerating available providers
///
/// This approach eliminates the boilerplate code previously required when adding new providers,
/// reducing maintenance burden and potential errors.
///
/// Registers multiple providers in a single declaration.
///
/// # Syntax
///
/// ```rust,ignore
/// register_providers!(
///     (module_name, "serde_name", ProviderType, EnumVariant),
///     // ... more providers
/// );
/// ```
///
/// Where:
/// - `module_name`: The provider module name (e.g., `openai_chat`)
/// - `"serde_name"`: The serde serialization name (e.g., `"openai_chat"`)
/// - `ProviderType`: The provider struct name (e.g., `OpenAiChatProvider`)
/// - `EnumVariant`: The `ProviderKind` enum variant name (e.g., `OpenAiChat`)
///
/// # Generated Code
///
/// This macro generates:
///
/// 1. **`ProviderKind` enum**: A serde-compatible enum with one variant per provider
/// 2. **`build_provider_from_config()` function**: Constructs a provider from `ModelConfig`
/// 3. **`list_provider_types()` function**: Returns a list of all registered provider names
///
/// # Requirements
///
/// Each registered provider must implement a static method:
///
/// ```rust,ignore
/// impl ProviderType {
///     pub fn from_model_config(
///         config: &crate::config::ModelConfig,
///         transport: crate::http::DynHttpTransport,
///     ) -> Result<Self, crate::error::LLMError>
///     where
///         Self: Sized,
///     {
///         // Construction logic here
///     }
/// }
/// ```
///
/// # Example
///
/// ```rust,ignore
/// use crate::provider::macros::register_providers;
///
/// register_providers!(
///     (openai_chat, "openai_chat", OpenAiChatProvider, OpenAiChat),
///     (anthropic_messages, "anthropic_messages", AnthropicMessagesProvider, AnthropicMessages),
/// );
/// ```
///
/// This generates a `ProviderKind` enum with `OpenAiChat` and `AnthropicMessages` variants.
#[macro_export]
macro_rules! register_providers {
    ($(($module:ident, $name:literal, $provider:ident, $variant:ident),)+) => {
        /// Enumerates the provider kinds supported by the configuration loader.
        ///
        /// This enum is automatically generated by the `register_providers!` macro.
        /// Each variant corresponds to a registered provider implementation.
        #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
        #[serde(rename_all = "snake_case")]
        pub enum ProviderKind {
            $(
                #[doc = concat!("The ", stringify!($provider), " provider.")]
                #[serde(rename = $name)]
                $variant,
            )+
        }

        impl ProviderKind {
            /// Returns a list of all registered provider type names.
            ///
            /// This is useful for validation, CLI help messages, and error reporting.
            pub fn list_provider_types() -> Vec<&'static str> {
                vec![$($name,)+]
            }

            /// Returns the string representation of this provider kind.
            pub fn as_str(&self) -> &'static str {
                match self {
                    $(
                        ProviderKind::$variant => $name,
                    )+
                }
            }
        }

        /// Builds a [`DynProvider`] from the provided [`ModelConfig`].
        ///
        /// This function is automatically generated by the `register_providers!` macro.
        /// It delegates to each provider's `from_model_config()` method.
        ///
        /// # Arguments
        ///
        /// * `config` - The model configuration containing provider kind and credentials
        /// * `transport` - The HTTP transport implementation to use
        ///
        /// # Returns
        ///
        /// A trait object wrapped in `Arc` that implements [`LLMProvider`].
        ///
        /// # Errors
        ///
        /// Returns [`LLMError::Auth`] when credentials are invalid or missing,
        /// [`LLMError::Validation`] for invalid configuration, or any provider-specific
        /// error raised during construction.
        pub fn build_provider_from_config(
            config: &$crate::config::ModelConfig,
            transport: $crate::http::DynHttpTransport,
        ) -> Result<$crate::provider::DynProvider, $crate::error::LLMError> {
            use std::sync::Arc;
            use $crate::config::ProviderKind;
            $(
                use $crate::provider::$module::$provider;
            )+

            let provider: $crate::provider::DynProvider = match &config.provider {
                $(
                    ProviderKind::$variant => {
                        Arc::new($provider::from_model_config(config, transport)?)
                    }
                )+
            };

            Ok(provider)
        }
    };
}
